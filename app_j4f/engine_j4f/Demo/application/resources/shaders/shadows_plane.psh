#version 450

#define SHADOW_MAP_CASCADE_COUNT 3

layout (location = 0) in vec2 in_uv;
layout (location = 1) in float in_viewDepth;
layout (location = 2) in vec3 in_position;

layout (location = 0) out vec4 out_color;

layout (set = 0, binding = 0) uniform shadow_UBO {
	vec4 cascade_splits;
	mat4 cascade_matrix[SHADOW_MAP_CASCADE_COUNT];
	mat4 view;
} u_shadow;

layout (set = 1, binding = 0) uniform sampler2DArrayShadow u_shadow_map;
layout (set = 2, binding = 0) uniform sampler2D u_texture;

float textureProj(vec4 shCoord, vec2 offset, uint cascade, float minLight) {
	//float dist = texture(u_shadow_map, vec3(shCoord.xy + offset, cascade)).r; // for sampler2DArray u_shadow_map;
		
	float bias = 0.001;
	float depth = shCoord.z - bias;
	//return mix(1.0, minLight, step(dist, depth));

	float dist = 1.0 - texture(u_shadow_map, vec4(shCoord.xy + offset, cascade, depth)).r; // for sampler2DArrayShadow u_shadow_map;
	return mix(1.0, minLight, dist);
}

float filterPCF(vec4 sc, uint cascade, float minLight) {
	ivec2 texDim = textureSize(u_shadow_map, 0).xy;
	float scale = 1.0;
	float dx = scale / float(texDim.x);
	float dy = scale / float(texDim.y);

	float shadowFactor = 0.0;
	int count = 0;
	int range = 1;

	for (int x = -range; x <= range; x++) {
		for (int y = -range; y <= range; y++) {
			shadowFactor += textureProj(sc, vec2(dx*x, dy*y), cascade, minLight);
			count++;
		}
	}
	return shadowFactor / count;
}

void main() {

// get cascade index for the current fragment's view position
	uint cascade = 0;
	for (uint i = 0; i < (SHADOW_MAP_CASCADE_COUNT - 1); ++i) {
		if (in_viewDepth < u_shadow.cascade_splits[i]) {	
			cascade = i + 1;
		}
	}

	vec4 shadowCoord = u_shadow.cascade_matrix[cascade] * vec4(in_position, 1.0);
	shadowCoord.xy = (shadowCoord.xy + 1.0) * 0.5;
	shadowCoord /= shadowCoord.w;
	float shadow = filterPCF(shadowCoord / shadowCoord.w, cascade, 0.5);

	out_color = texture(u_texture, in_uv, 0.0);
	out_color.rgb *= shadow;
}